<!doctype html>
<html>


<head>
	<meta charset="utf-8" />
	<meta name="apple-mobile-web-app-capable" content="yes">
	<meta name="apple-mobile-web-app-status-bar-style" content="black">
	<title>Space Junk Game</title>
	<style>

	body {
	background-color: #000000;
	margin: 0px;
	overflow: hidden;
	color: #ff8800;
	}


</style>
</head>

<body>

</body>

<script src="three.min.js"></script>
<script src="https://code.jquery.com/jquery-1.9.1.min.js"></script>
<script src="TrackballControls.js"></script>


<script>
function createPlanet(scene_name,radius,colour,group) {
	var material = new THREE.MeshBasicMaterial( {
		color: colour,
        // shading: THREE.SmoothShading,
        // transparent: true, 
        // opacity: 1.0
	} );
	var geometry = new THREE.SphereGeometry(radius,16,8);
	var meshname = new THREE.Mesh(geometry, material);
	group.add(meshname);

	scene_name.add(group);
}
</script>

<!-- Shaders -->
<script id="vertexShader" type="x-shader/x-vertex">
varying vec2 vUv;
varying vec3 vNormal;

void main() 
{
	vUv = uv; //Texture position
	vNormal = normal; // Calculate surface normal
	gl_Position =   projectionMatrix * modelViewMatrix * vec4(position,1.0);
}
</script>

<script id="fragmentShader" type="x-shader/x-fragment">
uniform sampler2D texture1;
uniform sampler2D texture2;
uniform sampler2D spectexture;
uniform sampler2D cloudtexture;
uniform vec3 sunDirection;
uniform vec3 viewDirection;

varying vec2 vUv;
varying vec3 vNormal;

void main() 
{

	vec3 view = normalize(viewDirection);

	// Values from textures using the texture coordinate from the vertex shader
	vec3 colorDay = texture2D(texture1, vUv).rgb;
	vec3 colorNight = texture2D(texture2, vUv).rgb;
	vec3 colorSpec = texture2D(spectexture, vUv).rgb;
	// Rather than a RGB colour for the clouds we just want a numerical value
	// In this case we use the red channel although this is obviosuly not ideal
	float cloudamount = texture2D(cloudtexture, vUv).r;

	//Calculate the diffuse component of the reflected light from the sun
	float sphere_diffuse = max(dot(normalize(vNormal), sunDirection), 0.0);

	// Calculate the amount of atmospheric reflection absed on viewer position
	float atmos_amount = max(dot(normalize(vNormal), sunDirection), 0.0);
	vec3 R  = 2.0 * ( dot(normalize(vNormal),sunDirection)) * normalize(vNormal) - sunDirection;
	vec3 E = view;

	//Calculate amount of specular light reflected
	//vec3 specular_value =  colorSpec * pow( max(dot(R,E), 0.0), 6.0 ); Not Working
	vec3 specular_value =  colorSpec * 0.0;

	vec3 lights;

	if (colorNight.r < 0.6) {
	lights = vec3(colorNight.r/3.0,colorNight.g/3.0,colorNight.b/1.5);
	} else {
	lights = vec3(colorNight.r*1.0,colorNight.g*0.8,colorNight.b*0.4);
	}

	colorNight=lights;

	// compute cosine sun to normal so -1 is away from sun and +1 is toward sun.
	float cosineAngleSunToNormal = dot(normalize(vNormal), sunDirection);

	// sharpen the edge beween the transition
	//cosineAngleSunToNormal = clamp( cosineAngleSunToNormal * 30.0, -1.0, 1.0);
	sphere_diffuse = clamp( sphere_diffuse * 10.0, -1.0, 1.0);

	// convert to 0 to 1 for mixing
	float mixAmount = cosineAngleSunToNormal * 0.5 + 0.5;

	// Select day or night texture based on mix.
	vec3 blue = vec3(0.2,0.4,0.8);
	vec3 color = mix( colorNight+vec3(0.1,0.1,0.2)*cloudamount, colorDay+(specular_value/1.3)+vec3(1.0,1.0,1.0)*cloudamount+blue*(1.0-atmos_amount), sphere_diffuse);

	gl_FragColor = vec4( color , 1.0 );

}
</script>

<!-- End Shaders -->
<script type="text/javascript">

var leo_debris_positionArray, leo_debris_velocityArray, leo_debris_objectArray;

var cleaner_positionArray, cleaner_velocityArray, cleaner_objectArray;

var mouse = new THREE.Vector2(), INTERSECTED;

var ring;
var target_altitude = 120;
var target_regime = 1;

var number_of_debris = 60;

var debris_size = 0.8;
var sphere;
var rotationamount = 0;
var camheight = 0;
var x = 0.0;
var z = 0.0;

var particle_buffer;

game_state = "active";

//document.getElementById("display_message").innerHTML="Select the target orbit using the buttons below. <br> Press LAUNCH to remove some junk!";

// set the scene size
var WIDTH = window.innerWidth,
HEIGHT = window.innerHeight;

// set some camera attributes
var VIEW_ANGLE = 45,
ASPECT = WIDTH / (HEIGHT),
NEAR = 0.1,
FAR = 100000;

raycaster = new THREE.Raycaster();

// create a WebGL renderer, camera
// and a scene
var renderer = new THREE.WebGLRenderer();
renderer.setPixelRatio( window.devicePixelRatio );
var camera = new THREE.PerspectiveCamera(  VIEW_ANGLE,
ASPECT,
NEAR,
FAR  );
var scene = new THREE.Scene();

camera.position.z = 200;
camera.position.y = 0.0;

controls = new THREE.TrackballControls( camera );
controls.rotateSpeed = 1.0;
controls.zoomSpeed = 1.2;
controls.panSpeed = 0.8;
controls.noZoom = false;
controls.noPan = true;
controls.staticMoving = true;
controls.dynamicDampingFactor = 0.1;

// start the renderer
renderer.setSize(WIDTH, HEIGHT);
document.body.appendChild( renderer.domElement );

// leo_selected(1);
target_regime = 1;

var pointLight = new THREE.PointLight(0xFFFFFF);

// set its position
pointLight.position.x = 0.5;
pointLight.position.y = 0.5;
pointLight.position.z = 0.5;

var uniforms = {
	sunDirection: { type: "v3", value: new THREE.Vector3(0.0, 0.0, 0.0) }, // Not Used!
	viewDirection: { type: "v3", value: new THREE.Vector3(0.0, 0.0, 0.0) }, // Not Used!
	texture1: { type: "t", value: THREE.ImageUtils.loadTexture( "earth1024.jpg" ) },
	texture2: { type: "t", value: THREE.ImageUtils.loadTexture( "EarthNight1024.jpg" ) }, 
	spectexture: { type: "t", value: THREE.ImageUtils.loadTexture( "EarthSpec.jpg" ) },
	cloudtexture: { type: "t", value: THREE.ImageUtils.loadTexture( "clouds1024.jpg" ) }
};

var vertShader = document.getElementById('vertexShader').innerHTML;
var fragShader = document.getElementById('fragmentShader').innerHTML;

// create the sphere's material
var shaderMaterial = new THREE.ShaderMaterial({
	uniforms: uniforms,
	vertexShader:   vertShader,
	fragmentShader: fragShader
});

// set up the sphere vars
var radius = 50, segments = 64, rings = 64;

// create a new mesh with sphere geometry -
// we will cover the sphereMaterial next!
var earth = new THREE.Mesh(
new THREE.SphereGeometry(radius, segments, rings),
shaderMaterial);

// add to the scene
scene.add(pointLight);

// add the sphere to the scene
scene.add(earth);
scene.add(camera);

camera.position.x = 1000;
camera.position.y = 1000;
camera.position.z = 0;

camera.lookAt(earth.position);

leo_debris_objectArray = [];
leo_debris_positionArray = [];
leo_debris_velocityArray = [];
leo_debris_state_array = [];
leo_debris_destroyed_array = [];

cleaner_objectArray = [];
cleaner_positionArray = [];
cleaner_velocityArray = [];
cleaner_regime_array = [];
cleaner_target_array = [];
cleaner_state_array = []

var scale = 1.0;
var acc_scale = 1;
var vel_scale = 1;

leo_start_index = 0;
leo_end_index = 50;
leo_destroyed = 0;

meo_start_index = 0;
meo_end_index = 50;
// meo_destroyed = 0;

geo_start_index = 0;
geo_end_index = 50;
// geo_destroyed = 0;

//Create Debris
var GM = 100;

function create_debris(altitude, position_array, velocity_array, object_array, state_array, destroyed_array, colour, axis)
{
	var speed = Math.sqrt(GM / altitude); 
	var pos = new THREE.Vector3(1,0,0);
	// var axis = new THREE.Vector3(Math.random()-0.5,Math.random()-0.5,Math.random()-0.5).normalize();
	var angle = Math.random()*2*3.14;
	pos.applyAxisAngle(axis, angle);
	var vel = axis.cross(pos).normalize().multiplyScalar(speed);
	position_array.push(pos.multiplyScalar(altitude));
	velocity_array.push(vel);
	// var color = new THREE.Color( 0.8, Math.random()*0.25, Math.random()*0.25 );
	scobject = new THREE.Object3D();
	createPlanet(scene, 5 , colour, scobject);
	object_array.push(scobject);
	state_array.push(0);
	destroyed_array.push(0);
}

function create_cleaner(e, regime, target)
{
	// Basic Removal
	number_of_debris = number_of_debris - 1;
	// document.getElementById("pieces_of_junk").innerHTML=number_of_debris;
	altitude = 55;

	// Create a cleaner
	var pos = new THREE.Vector3(1,0,0);
	var axis = new THREE.Vector3(0,1,0).normalize();

	var angle = Math.random()*2*3.14;
	pos.applyAxisAngle(axis, angle);
	var speed = Math.sqrt(GM / altitude);
	var vel = axis.cross(pos).normalize().multiplyScalar(speed);

	cleaner_positionArray.push(pos.multiplyScalar(altitude));
	cleaner_velocityArray.push(vel);
	var color = new THREE.Color( 1,1,1 );
	scobject = new THREE.Object3D();
	createPlanet(scene, 8 , color, scobject);
	cleaner_objectArray.push(scobject);
	cleaner_regime_array.push(regime);
	cleaner_target_array.push(target);
	cleaner_state_array.push(0);
}

leo_target = 0;
meo_target = 0;
geo_target = 0;

// // Create LEO
for(var i=leo_start_index; i<leo_end_index; i++) {
	leo_colour = new THREE.Color( Math.random()*0.1 + 0.1 , Math.random()*0.1 + 0.1, Math.random()*0.1 + 0.1 );
	leo_axis = new THREE.Vector3(Math.random()-0.5,Math.random()-0.5,Math.random()-0.5).normalize();
	create_debris(120, leo_debris_positionArray, leo_debris_velocityArray, leo_debris_objectArray, leo_debris_state_array, leo_debris_destroyed_array, leo_colour, leo_axis );
}

// // Create MEO
for(var i=meo_start_index; i<meo_end_index; i++) {
	meo_colour = new THREE.Color( Math.random()*0.1 + 0.1 ,Math.random()*0.1 + 0.1 , Math.random()*0.1 + 0.1 );
	meo_axis = new THREE.Vector3(Math.random()-0.5,Math.random()-0.5,Math.random()-0.5).normalize();
	create_debris(240, leo_debris_positionArray, leo_debris_velocityArray, leo_debris_objectArray, leo_debris_state_array, leo_debris_destroyed_array, meo_colour, meo_axis );
}

// // Create GEO
for(var i=geo_start_index; i<geo_end_index; i++) {
	geo_colour = new THREE.Color( Math.random()*0.1 + 0.1, Math.random()*0.1 + 0.1, Math.random()*0.1 + 0.1 )
	geo_axis = new THREE.Vector3(0,1,0).normalize();
	create_debris(400, leo_debris_positionArray, leo_debris_velocityArray, leo_debris_objectArray, leo_debris_state_array, leo_debris_destroyed_array, geo_colour, geo_axis );
}


function render(){
renderer.render(scene, camera);


function render_debris(position_array, velocity_array, object_array, i)
{

	radius = position_array[i].length();

	acceleration = -GM / (radius*radius);

	acc_vector = position_array[i].clone();

	acc_vector.divideScalar(radius).multiplyScalar(acceleration);

	velocity_array[i].x = velocity_array[i].x + acc_vector.x/acc_scale;
	velocity_array[i].y = velocity_array[i].y + acc_vector.y/acc_scale;
	velocity_array[i].z = velocity_array[i].z + acc_vector.z/acc_scale;

	position_array[i].x = position_array[i].x + velocity_array[i].x/vel_scale;
	position_array[i].y = position_array[i].y + velocity_array[i].y/vel_scale;
	position_array[i].z = position_array[i].z + velocity_array[i].z/vel_scale;

	object_array[i].position.set(position_array[i].x*scale, position_array[i].y*scale, position_array[i].z*scale);

}


if (game_state != "paused" && game_state != "game_over")
{

// // Render LEO Debris
for(var i=leo_start_index; i<leo_debris_objectArray.length; i++) {
	if (leo_debris_destroyed_array[i] == 0){
		render_debris(leo_debris_positionArray, leo_debris_velocityArray, leo_debris_objectArray, i);
	}
}

// Render LEO Cleaner
if ( cleaner_objectArray.length > 0){

	for(var i=0; i<cleaner_objectArray.length; i++) {
		if (cleaner_state_array[i] != -1){

			if (cleaner_regime_array[i] == 1){


				var target_vec = new THREE.Vector3();
				target_vec.subVectors(leo_debris_positionArray[cleaner_target_array[i]], cleaner_positionArray[i]);
				target_distance = target_vec.length();
				target_dir = target_vec.normalize();

				if (target_distance > 2.0)
				{
					cleaner_positionArray[i].x = cleaner_positionArray[i].x + target_vec.x*3;
					cleaner_positionArray[i].y = cleaner_positionArray[i].y + target_vec.y*3;
					cleaner_positionArray[i].z = cleaner_positionArray[i].z + target_vec.z*3;
				}
				else if (leo_debris_state_array[cleaner_target_array[i]] < 1.0)
				{
					cleaner_positionArray[i] = leo_debris_positionArray[cleaner_target_array[i]];
					cleaner_objectArray[i].children[0].material.color.b = 0.0;

					scale_factor = 1 - leo_debris_state_array[cleaner_target_array[i]];

					cleaner_objectArray[i].children[0].scale.set(scale_factor,scale_factor,scale_factor);
					leo_debris_objectArray[cleaner_target_array[i]].children[0].scale.set(scale_factor,scale_factor,scale_factor);

					leo_debris_state_array[cleaner_target_array[i]] = leo_debris_state_array[cleaner_target_array[i]] + 0.02;
					
				}
				else
				{
					cleaner_positionArray[i] = new THREE.Vector3( 0.0, 0.0, 0.0 );
					leo_debris_positionArray[cleaner_target_array[i]] = new THREE.Vector3( 0.0, 0.0, 0.0 );
					leo_destroyed = leo_destroyed +1;

					leo_debris_state_array[cleaner_target_array[i]] = -0.01;
					cleaner_state_array[i] = -1;
					scene.remove(leo_debris_objectArray[cleaner_target_array[i]]);
					scene.remove(cleaner_objectArray[i]); 
					leo_debris_destroyed_array[cleaner_target_array[i]] = 1;

				}
				
				cleaner_objectArray[i].position.set(cleaner_positionArray[i].x*scale,cleaner_positionArray[i].y*scale,cleaner_positionArray[i].z*scale);
			}
			
		}

	}

}
	

}

controls.update();

}

function checkIntersection(){
	raycaster.setFromCamera( mouse, camera );

	intersects = raycaster.intersectObjects( scene.children, true );

	if ( intersects.length > 0 ) {

		if ( INTERSECTED != intersects[ 0 ].object ) {

			INTERSECTED = intersects[ 0 ].object;
			// INTERSECTED.currentHex = INTERSECTED.material.color.getHex();
			INTERSECTED.material.color.setHex( 0xff0000 );
			INTERSECTED.scale.set(0.5, 0.5, 0.5);
			// scene.remove(INTERSECTED);

		}

	} else {

		INTERSECTED = null;

	}
}

function onTouch(event){
	mouse.x = ( event.originalEvent.touches[0].pageX / window.innerWidth ) * 2 - 1;
	mouse.y = ( ( event.originalEvent.touches[0].pageY / window.innerHeight ) * 2 - 1) *-1;
	checkIntersection()
}

function onClick(event){
	mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
	mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
	checkIntersection()
}

$("body").click(function(event) {
	event.preventDefault();
	onClick(event);
});

$("body").on('touchstart', function(event){

  	event.preventDefault();
	onTouch(event);
});

function update(){


if (game_state != "paused" && game_state != "game_over")
{

	rotationamount += 0.002
	
	uniforms["sunDirection"].value = new THREE.Vector3(Math.sin( -rotationamount * 2.9),0.2,Math.cos( rotationamount * 2.9));
	uniforms["viewDirection"].value = new THREE.Vector3(camera.position.x,camera.position.y,camera.position.z);

	}

	total_cleaned = 0;
	for(var i=0; i<cleaner_state_array.length; i++) {
		if (cleaner_state_array[i] == -1){
			total_cleaned = total_cleaned + 1;
		}
	}
	
}

function animate() 
{
	requestAnimationFrame( animate );
	render();		
	update();
}

animate();

</script>
</html>
