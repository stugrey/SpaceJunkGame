<!doctype html>
<html>


<head>
	<meta charset="utf-8" />
	<meta name="apple-mobile-web-app-capable" content="yes">
	<meta name="apple-mobile-web-app-status-bar-style" content="black">
	<title>Space Junk Game</title>
	<style>

	body {
	background-color: #000000;
	margin: 0px;
	overflow: hidden;
	color: #ff8800;
	}


</style>
</head>

<body>

</body>

<script src="three.min.js"></script>
<script src="https://code.jquery.com/jquery-1.9.1.min.js"></script>
<script src="TrackballControls.js"></script>


<script>
function createPlanet(scene_name,radius,colour,group) {
	var material = new THREE.MeshBasicMaterial( {
		color: colour,
        // shading: THREE.SmoothShading,
        // transparent: true, 
        // opacity: 1.0
	} );
	var geometry = new THREE.SphereGeometry(radius,2,2);
	var meshname = new THREE.Mesh(geometry, material);
	group.add(meshname);

	scene_name.add(group);
}
</script>

<!-- Shaders -->
<script id="vertexShader" type="x-shader/x-vertex">
varying vec2 vUv;
varying vec3 vNormal;

void main() 
{
	vUv = uv; //Texture position
	vNormal = normal; // Calculate surface normal
	gl_Position =   projectionMatrix * modelViewMatrix * vec4(position,1.0);
}
</script>

<script id="fragmentShader" type="x-shader/x-fragment">
uniform sampler2D texture1;
uniform sampler2D texture2;
uniform sampler2D spectexture;
uniform sampler2D cloudtexture;
uniform vec3 sunDirection;
uniform vec3 viewDirection;

varying vec2 vUv;
varying vec3 vNormal;

void main() 
{

	vec3 view = normalize(viewDirection);

	// Values from textures using the texture coordinate from the vertex shader
	vec3 colorDay = texture2D(texture1, vUv).rgb;
	vec3 colorNight = texture2D(texture2, vUv).rgb;
	vec3 colorSpec = texture2D(spectexture, vUv).rgb;
	// Rather than a RGB colour for the clouds we just want a numerical value
	// In this case we use the red channel although this is obviosuly not ideal
	float cloudamount = texture2D(cloudtexture, vUv).r;

	//Calculate the diffuse component of the reflected light from the sun
	float sphere_diffuse = max(dot(normalize(vNormal), sunDirection), 0.0);

	// Calculate the amount of atmospheric reflection absed on viewer position
	float atmos_amount = max(dot(normalize(vNormal), sunDirection), 0.0);
	vec3 R  = 2.0 * ( dot(normalize(vNormal),sunDirection)) * normalize(vNormal) - sunDirection;
	vec3 E = view;

	//Calculate amount of specular light reflected
	//vec3 specular_value =  colorSpec * pow( max(dot(R,E), 0.0), 6.0 ); Not Working
	vec3 specular_value =  colorSpec * 0.0;

	vec3 lights;

	if (colorNight.r < 0.6) {
	lights = vec3(colorNight.r/3.0,colorNight.g/3.0,colorNight.b/1.5);
	} else {
	lights = vec3(colorNight.r*1.0,colorNight.g*0.8,colorNight.b*0.4);
	}

	colorNight=lights;

	// compute cosine sun to normal so -1 is away from sun and +1 is toward sun.
	float cosineAngleSunToNormal = dot(normalize(vNormal), sunDirection);

	// sharpen the edge beween the transition
	//cosineAngleSunToNormal = clamp( cosineAngleSunToNormal * 30.0, -1.0, 1.0);
	sphere_diffuse = clamp( sphere_diffuse * 10.0, -1.0, 1.0);

	// convert to 0 to 1 for mixing
	float mixAmount = cosineAngleSunToNormal * 0.5 + 0.5;

	// Select day or night texture based on mix.
	vec3 blue = vec3(0.2,0.4,0.8);
	vec3 color = mix( colorNight+vec3(0.1,0.1,0.2)*cloudamount, colorDay+(specular_value/1.3)+vec3(1.0,1.0,1.0)*cloudamount+blue*(1.0-atmos_amount), sphere_diffuse);

	gl_FragColor = vec4( color , 1.0 );

}
</script>

<!-- End Shaders -->
<script type="text/javascript">

var leo_debris_positionArray, leo_debris_velocityArray, leo_debris_objectArray;

var cleaner_positionArray, cleaner_velocityArray, cleaner_objectArray;

var mouse = new THREE.Vector2(), INTERSECTED;

var velocity = [];

var ring;
var target_altitude = 120;
var target_regime = 1;

var number_of_debris = 60;

var debris_size = 0.8;
var sphere;
var rotationamount = 0;
var camheight = 0;
var x = 0.0;
var z = 0.0;

var particle_buffer;

game_state = "active";

//document.getElementById("display_message").innerHTML="Select the target orbit using the buttons below. <br> Press LAUNCH to remove some junk!";

// set the scene size
var WIDTH = window.innerWidth,
HEIGHT = window.innerHeight;

// set some camera attributes
var VIEW_ANGLE = 45,
ASPECT = WIDTH / (HEIGHT),
NEAR = 0.1,
FAR = 100000;

raycaster = new THREE.Raycaster();

// create a WebGL renderer, camera
// and a scene
var renderer = new THREE.WebGLRenderer();
renderer.setPixelRatio( window.devicePixelRatio );
var camera = new THREE.PerspectiveCamera(  VIEW_ANGLE,
ASPECT,
NEAR,
FAR  );
var scene = new THREE.Scene();

camera.position.z = 200;
camera.position.y = 0.0;

controls = new THREE.TrackballControls( camera );
controls.rotateSpeed = 1.0;
controls.zoomSpeed = 1.2;
controls.panSpeed = 0.8;
controls.noZoom = false;
controls.noPan = true;
controls.staticMoving = true;
controls.dynamicDampingFactor = 0.1;

// start the renderer
renderer.setSize(WIDTH, HEIGHT);
document.body.appendChild( renderer.domElement );

// leo_selected(1);
target_regime = 1;

var pointLight = new THREE.PointLight(0xFFFFFF);

// set its position
pointLight.position.x = 0.5;
pointLight.position.y = 0.5;
pointLight.position.z = 0.5;

var uniforms = {
	sunDirection: { type: "v3", value: new THREE.Vector3(0.0, 0.0, 0.0) }, // Not Used!
	viewDirection: { type: "v3", value: new THREE.Vector3(0.0, 0.0, 0.0) }, // Not Used!
	texture1: { type: "t", value: THREE.ImageUtils.loadTexture( "earth1024.jpg" ) },
	texture2: { type: "t", value: THREE.ImageUtils.loadTexture( "EarthNight1024.jpg" ) }, 
	spectexture: { type: "t", value: THREE.ImageUtils.loadTexture( "EarthSpec.jpg" ) },
	cloudtexture: { type: "t", value: THREE.ImageUtils.loadTexture( "clouds1024.jpg" ) }
};

var vertShader = document.getElementById('vertexShader').innerHTML;
var fragShader = document.getElementById('fragmentShader').innerHTML;

// create the sphere's material
var shaderMaterial = new THREE.ShaderMaterial({
	uniforms: uniforms,
	vertexShader:   vertShader,
	fragmentShader: fragShader
});

// set up the sphere vars
var radius = 50, segments = 64, rings = 64;

// create a new mesh with sphere geometry -
// we will cover the sphereMaterial next!
var earth = new THREE.Mesh(
new THREE.SphereGeometry(radius, segments, rings),
shaderMaterial);

// add to the scene
scene.add(pointLight);

// add the sphere to the scene
scene.add(earth);
scene.add(camera);

camera.position.x = 1000;
camera.position.y = 1000;
camera.position.z = 0;

camera.lookAt(earth.position);

leo_debris_objectArray = [];
leo_debris_positionArray = [];
leo_debris_velocityArray = [];
leo_debris_state_array = [];
leo_debris_destroyed_array = [];

cleaner_objectArray = [];
cleaner_positionArray = [];
cleaner_velocityArray = [];
cleaner_regime_array = [];
cleaner_target_array = [];
cleaner_state_array = []

var scale = 1.0;
var acc_scale = 1;
var vel_scale = 1;

leo_start_index = 0;
leo_end_index = 600;
leo_destroyed = 0;

meo_start_index = 0;
meo_end_index = 600;
// meo_destroyed = 0;

geo_start_index = 0;
geo_end_index = 600;
// geo_destroyed = 0;

//Create Debris
var GM = 100;

function create_debris(altitude, position_array, velocity_array, object_array, state_array, destroyed_array, colour, axis)
{
	var speed = Math.sqrt(GM / altitude); 
	var pos = new THREE.Vector3(1,0,0);
	// var axis = new THREE.Vector3(Math.random()-0.5,Math.random()-0.5,Math.random()-0.5).normalize();
	var angle = Math.random()*2*3.14;
	pos.applyAxisAngle(axis, angle);
	var vel = axis.cross(pos).normalize().multiplyScalar(speed);
	position_array.push(pos.multiplyScalar(altitude));
	velocity_array.push(vel);
	// var color = new THREE.Color( 0.8, Math.random()*0.25, Math.random()*0.25 );
	scobject = new THREE.Object3D();
	// createPlanet(scene, 5 , colour, scobject);
	object_array.push(scobject);
	state_array.push(0);
	destroyed_array.push(0);
}

function create_cleaner(e, regime, target)
{
	// Basic Removal
	number_of_debris = number_of_debris - 1;
	// document.getElementById("pieces_of_junk").innerHTML=number_of_debris;
	altitude = 55;

	// Create a cleaner
	var pos = new THREE.Vector3(1,0,0);
	var axis = new THREE.Vector3(0,1,0).normalize();

	var angle = Math.random()*2*3.14;
	pos.applyAxisAngle(axis, angle);
	var speed = Math.sqrt(GM / altitude);
	var vel = axis.cross(pos).normalize().multiplyScalar(speed);

	cleaner_positionArray.push(pos.multiplyScalar(altitude));
	cleaner_velocityArray.push(vel);
	var color = new THREE.Color( 1,1,1 );
	scobject = new THREE.Object3D();
	createPlanet(scene, 8 , color, scobject);
	cleaner_objectArray.push(scobject);
	cleaner_regime_array.push(regime);
	cleaner_target_array.push(target);
	cleaner_state_array.push(0);
}

leo_target = 0;
meo_target = 0;
geo_target = 0;

leo_colour = new THREE.Color( Math.random()*0.1 + 0.3 , Math.random()*0.1 + 0.6, Math.random()*0.1 + 0.3 );

// // Create LEO
for(var i=leo_start_index; i<leo_end_index; i++) {
	leo_axis = new THREE.Vector3(Math.random()-0.5,Math.random()-0.5,Math.random()-0.5).normalize();
	create_debris(120, leo_debris_positionArray, leo_debris_velocityArray, leo_debris_objectArray, leo_debris_state_array, leo_debris_destroyed_array, leo_colour, leo_axis );
}

// // Create MEO
for(var i=meo_start_index; i<meo_end_index; i++) {
	meo_axis = new THREE.Vector3(Math.random()-0.5,Math.random()-0.5,Math.random()-0.5).normalize();
	create_debris(240, leo_debris_positionArray, leo_debris_velocityArray, leo_debris_objectArray, leo_debris_state_array, leo_debris_destroyed_array, leo_colour, meo_axis );
}

// // Create GEO
for(var i=geo_start_index; i<geo_end_index; i++) {
	geo_axis = new THREE.Vector3(0,1,0).normalize();
	create_debris(400, leo_debris_positionArray, leo_debris_velocityArray, leo_debris_objectArray, leo_debris_state_array, leo_debris_destroyed_array, leo_colour, geo_axis );
}

scene.add( new THREE.AmbientLight( 0x444444 ) );

var light1 = new THREE.DirectionalLight( 0xffffff, 0.5 );
light1.position.set( 1, 1, 1 );
scene.add( light1 );

var light2 = new THREE.DirectionalLight( 0xffffff, 1.5 );
light2.position.set( 0, -1, 0 );
scene.add( light2 );

//

var triangles = leo_end_index + meo_end_index + geo_end_index;

var geometry = new THREE.BufferGeometry();

// break geometry into
// chunks of 21,845 triangles (3 unique vertices per triangle)
// for indices to fit into 16 bit integer number
// floor(2^16 / 3) = 21845

var chunkSize = 21845;

var indices = new Uint16Array( triangles * 3 );

for ( var i = 0; i < indices.length; i ++ ) {

	indices[ i ] = i % ( 3 * chunkSize );

}

positions = new Float32Array( triangles * 3 * 3 );
var normals = new Float32Array( triangles * 3 * 3 );
var colors = new Float32Array( triangles * 3 * 3 );

var color = new THREE.Color();

var n = 800, n2 = n/2;	// triangles spread in the cube
var d = 12, d2 = d/2;	// individual triangle size

var pA = new THREE.Vector3();
var pB = new THREE.Vector3();
var pC = new THREE.Vector3();

var cb = new THREE.Vector3();
var ab = new THREE.Vector3();

for ( var i = 0; i < positions.length; i += 9 ) {

	// velocity
	velocity.push(new THREE.Vector3( Math.random()-0.5, Math.random()-0.5 , Math.random()-0.5 ));

	// positions

	var x = leo_debris_positionArray[i/9].x;
	var y = leo_debris_positionArray[i/9].y;
	var z = leo_debris_positionArray[i/9].z;

	var ax = x + Math.random() * d - d2;
	var ay = y + Math.random() * d - d2;
	var az = z + Math.random() * d - d2;

	var bx = x + Math.random() * d - d2;
	var by = y + Math.random() * d - d2;
	var bz = z + Math.random() * d - d2;

	var cx = x + Math.random() * d - d2;
	var cy = y + Math.random() * d - d2;
	var cz = z + Math.random() * d - d2;

	positions[ i ]     = ax;
	positions[ i + 1 ] = ay;
	positions[ i + 2 ] = az;

	positions[ i + 3 ] = bx;
	positions[ i + 4 ] = by;
	positions[ i + 5 ] = bz;

	positions[ i + 6 ] = cx;
	positions[ i + 7 ] = cy;
	positions[ i + 8 ] = cz;

	// flat face normals

	pA.set( ax, ay, az );
	pB.set( bx, by, bz );
	pC.set( cx, cy, cz );

	cb.subVectors( pC, pB );
	ab.subVectors( pA, pB );
	cb.cross( ab );

	cb.normalize();

	var nx = cb.x;
	var ny = cb.y;
	var nz = cb.z;

	normals[ i ]     = nx;
	normals[ i + 1 ] = ny;
	normals[ i + 2 ] = nz;

	normals[ i + 3 ] = nx;
	normals[ i + 4 ] = ny;
	normals[ i + 5 ] = nz;

	normals[ i + 6 ] = nx;
	normals[ i + 7 ] = ny;
	normals[ i + 8 ] = nz;

	// colors

	var vx = Math.random()/0.5 + 0.5;
	var vy = Math.random()/0.5 + 0.5;
	var vz = Math.random()/0.5 + 0.5;

	color.setRGB( vx, vy, vz );

	colors[ i ]     = color.r;
	colors[ i + 1 ] = color.g;
	colors[ i + 2 ] = color.b;

	colors[ i + 3 ] = color.r;
	colors[ i + 4 ] = color.g;
	colors[ i + 5 ] = color.b;

	colors[ i + 6 ] = color.r;
	colors[ i + 7 ] = color.g;
	colors[ i + 8 ] = color.b;

}

geometry.addAttribute( 'index', new THREE.BufferAttribute( indices, 1 ) );
geometry.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
geometry.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );
geometry.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ) );

var offsets = triangles / chunkSize;

for ( var i = 0; i < offsets; i ++ ) {

	var offset = {
		start: i * chunkSize * 3,
		index: i * chunkSize * 3,
		count: Math.min( triangles - ( i * chunkSize ), chunkSize ) * 3
	};

	geometry.offsets.push( offset );

}

geometry.computeBoundingSphere();

// var material = new THREE.MeshPhongMaterial( {
// 	color: 0xaaaaaa, specular: 0xffffff, shininess: 250,
// 	side: THREE.DoubleSide, vertexColors: THREE.VertexColors
// } );

var material = new THREE.MeshPhongMaterial( {
	color: 0xaaaaaa, specular: 0xffffff, shininess: 250,
	vertexColors: THREE.VertexColors
} );

// var material = new THREE.MeshBasicMaterial( {
// 	color: 0xaaaaaa, vertexColors: THREE.VertexColors
// } );



mesh = new THREE.Mesh( geometry, material );
scene.add( mesh );

sphere_group = [];


var geometry = new THREE.SphereGeometry( 20, 20, 20 );

for ( var i = 0; i < 10; i ++ ) {

	var object = new THREE.Mesh( geometry, new THREE.MeshBasicMaterial( { color: Math.random() * 0xffffff } ) );

	object.position.x = Math.random() * 800 - 400;
	object.position.y = Math.random() * 800 - 400;
	object.position.z = Math.random() * 800 - 400;

	object.rotation.x = Math.random() * 2 * Math.PI;
	object.rotation.y = Math.random() * 2 * Math.PI;
	object.rotation.z = Math.random() * 2 * Math.PI;

	object.scale.x = 5;
	object.scale.y = 5;
	object.scale.z = 5;

	sc_object = new THREE.Object3D();
	sc_object.add(object);

	sphere_group.push(sc_object);

	scene.add(sc_object);




}









function render(){
renderer.render(scene, camera);


function render_debris(position_array, velocity_array, object_array, i)
{

	radius = position_array[i].length();

	acceleration = -GM / (radius*radius);

	acc_vector = position_array[i].clone();

	acc_vector.divideScalar(radius).multiplyScalar(acceleration);

	velocity_array[i].x = velocity_array[i].x + acc_vector.x/acc_scale;
	velocity_array[i].y = velocity_array[i].y + acc_vector.y/acc_scale;
	velocity_array[i].z = velocity_array[i].z + acc_vector.z/acc_scale;

	position_array[i].x = position_array[i].x + velocity_array[i].x/vel_scale;
	position_array[i].y = position_array[i].y + velocity_array[i].y/vel_scale;
	position_array[i].z = position_array[i].z + velocity_array[i].z/vel_scale;

	//object_array[i].position.set(position_array[i].x*scale, position_array[i].y*scale, position_array[i].z*scale);

}


if (game_state != "paused" && game_state != "game_over")
{

// // Render LEO Debris
for(var i=leo_start_index; i<leo_debris_objectArray.length; i++) {
	if (leo_debris_destroyed_array[i] == 0){
		render_debris(leo_debris_positionArray, leo_debris_velocityArray, leo_debris_objectArray, i);
	}
}

// Render LEO Cleaner
if ( cleaner_objectArray.length > 0){

	for(var i=0; i<cleaner_objectArray.length; i++) {
		if (cleaner_state_array[i] != -1){

			if (cleaner_regime_array[i] == 1){


				var target_vec = new THREE.Vector3();
				target_vec.subVectors(leo_debris_positionArray[cleaner_target_array[i]], cleaner_positionArray[i]);
				target_distance = target_vec.length();
				target_dir = target_vec.normalize();

				if (target_distance > 2.0)
				{
					cleaner_positionArray[i].x = cleaner_positionArray[i].x + target_vec.x*3;
					cleaner_positionArray[i].y = cleaner_positionArray[i].y + target_vec.y*3;
					cleaner_positionArray[i].z = cleaner_positionArray[i].z + target_vec.z*3;
				}
				else if (leo_debris_state_array[cleaner_target_array[i]] < 1.0)
				{
					cleaner_positionArray[i] = leo_debris_positionArray[cleaner_target_array[i]];
					cleaner_objectArray[i].children[0].material.color.b = 0.0;

					scale_factor = 1 - leo_debris_state_array[cleaner_target_array[i]];

					cleaner_objectArray[i].children[0].scale.set(scale_factor,scale_factor,scale_factor);
					leo_debris_objectArray[cleaner_target_array[i]].children[0].scale.set(scale_factor,scale_factor,scale_factor);

					leo_debris_state_array[cleaner_target_array[i]] = leo_debris_state_array[cleaner_target_array[i]] + 0.02;
					
				}
				else
				{
					cleaner_positionArray[i] = new THREE.Vector3( 0.0, 0.0, 0.0 );
					leo_debris_positionArray[cleaner_target_array[i]] = new THREE.Vector3( 0.0, 0.0, 0.0 );
					leo_destroyed = leo_destroyed +1;

					leo_debris_state_array[cleaner_target_array[i]] = -0.01;
					cleaner_state_array[i] = -1;
					scene.remove(leo_debris_objectArray[cleaner_target_array[i]]);
					scene.remove(cleaner_objectArray[i]); 
					leo_debris_destroyed_array[cleaner_target_array[i]] = 1;

				}
				
				cleaner_objectArray[i].position.set(cleaner_positionArray[i].x*scale,cleaner_positionArray[i].y*scale,cleaner_positionArray[i].z*scale);
			}
			
		}

	}

}

for ( var i = 0; i < positions.length; i += 9 ) {

					positions[ i ]     = positions[ i ] + leo_debris_velocityArray[i/9].x;
					positions[ i + 1 ] = positions[ i + 1] + leo_debris_velocityArray[i/9].y;
					positions[ i + 2 ] = positions[ i + 2] + leo_debris_velocityArray[i/9].z;

					positions[ i + 3 ] = positions[ i + 3] + leo_debris_velocityArray[i/9].x;
					positions[ i + 4 ] = positions[ i + 4] + leo_debris_velocityArray[i/9].y;
					positions[ i + 5 ] = positions[ i + 5] + leo_debris_velocityArray[i/9].z;

					positions[ i + 6 ] = positions[ i + 6] + leo_debris_velocityArray[i/9].x;
					positions[ i + 7 ] = positions[ i + 7] + leo_debris_velocityArray[i/9].y;
					positions[ i + 8 ] = positions[ i + 8] + leo_debris_velocityArray[i/9].z;

				}

				mesh.geometry.attributes.position.needsUpdate = true;
	

}

controls.update();

}

function checkIntersection(){
	raycaster.setFromCamera( mouse, camera );

	intersects = raycaster.intersectObjects( sphere_group, true );

	if ( intersects.length > 0 ) {

		if ( INTERSECTED != intersects[ 0 ].object ) {

			INTERSECTED = intersects[ 0 ].object;
			// INTERSECTED.currentHex = INTERSECTED.material.color.getHex();
			INTERSECTED.material.color.setHex( 0xff0000 );
			INTERSECTED.scale.set(0.5, 0.5, 0.5);
			// scene.remove(INTERSECTED);

		}

	} else {

		INTERSECTED = null;

	}
}

function onTouch(event){
	mouse.x = ( event.originalEvent.touches[0].pageX / window.innerWidth ) * 2 - 1;
	mouse.y = ( ( event.originalEvent.touches[0].pageY / window.innerHeight ) * 2 - 1) *-1;
	checkIntersection()
}

function onClick(event){
	mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
	mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
	checkIntersection()
}

$("body").click(function(event) {
	event.preventDefault();
	onClick(event);
});

$("body").on('touchstart', function(event){

  	event.preventDefault();
	onTouch(event);
});

function update(){


if (game_state != "paused" && game_state != "game_over")
{

	rotationamount += 0.002
	
	uniforms["sunDirection"].value = new THREE.Vector3(Math.sin( -rotationamount * 2.9),0.2,Math.cos( rotationamount * 2.9));
	uniforms["viewDirection"].value = new THREE.Vector3(camera.position.x,camera.position.y,camera.position.z);

	}

	total_cleaned = 0;
	for(var i=0; i<cleaner_state_array.length; i++) {
		if (cleaner_state_array[i] == -1){
			total_cleaned = total_cleaned + 1;
		}
	}
	
}

function animate() 
{
	requestAnimationFrame( animate );
	render();		
	update();
}

animate();

</script>
</html>
